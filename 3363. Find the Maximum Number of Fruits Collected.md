[LC.3363](https://leetcode.com/problems/find-the-maximum-number-of-fruits-collected/description/)


# Intuition

Three children collect fruits in a $$n\times n$$ grid. We divide the problem into three clear parts:

1. **Child 1 (Top-left → Bottom-right)**
   - Starts at $$(0,0)$$ and must reach $$(n-1,n-1)$$ in $$n-1$$ moves.
   - With only down or right moves, the only path is the **main diagonal**.
   - We sum fruits on $$(0,0), (1,1), \dots, (n-1,n-1)$$ and then clear those cells.

2. **Child 2 (Top-right → Bottom-right)**
   - Starts at $$(0,n-1)$$.
   - Moves one row down per step, shifting column by $$-1,0,+1$$ (down-left, down, down-right).
   - We use a 1D DP array to track the best fruit total for each column in the current row.

3. **Child 3 (Bottom-left → Bottom-right)**
   - Starts at $$(n-1,0)$$.
   - Moves one column right per step, shifting row by $$-1,0,+1$$ (up-right, right, down-right).
   - This is the **transpose** of Child 2’s movement pattern.
   - We transpose the grid in place and reuse the same DP routine.

# Approach

1. **Collect & clear Child 1’s diagonal**
   ```python
   total = sum(fruits[i][i] for i in range(n))
   for i in range(n):
       fruits[i][i] = 0
   # 'total' now holds the diagonal fruits, and those cells are zero.
   ```

2. **Define the 1D DP helper `collect_max`**
   - **State:** `prev[c]` = max fruits collected when the child finishes the previous row at column `c`.
   - **Initialization:**
     ```python
     prev = [float('-inf')] * n
     prev[n-1] = fruits[0][n-1]   # start at top-right
     ```
   - **For each row r = 1…n−1:**
     ```python
     curr = [float('-inf')] * n
     lo = max(0, n-1-r)          # leftmost column reachable in row r
     for c in range(lo, n):
         # best from down, down-left, or down-right
         m = prev[c]
         if c > 0:
             m = max(m, prev[c-1])
         if c+1 < n:
             m = max(m, prev[c+1])
         curr[c] = m + fruits[r][c]
     prev = curr
     ```
   - **Result:**
     ```python
     return prev[n-1]  # max fruits reaching (n-1, n-1)
     ```

3. **Compute final answer**
   ```python
   # 1) Diagonal harvest for Child 1
   ans = total

   # 2) Child 2 on original grid
   ans += collect_max()

   # 3) Transpose grid for Child 3
   for i in range(n):
       for j in range(i):
           fruits[i][j], fruits[j][i] = fruits[j][i], fruits[i][j]

   # 4) Child 3 on transposed grid
   ans += collect_max()

   return ans
   ```

---

# Complexity

- **Time:**
  - Clearing diagonal: O(n)
  - Each 1D DP pass: O(n rows × up to n columns) = O(n²)
  - Transpose: O(n²)
  → **O(n²)** overall

- **Space:**
  - In-place grid modification: O(1) extra
  - Two DP arrays of length n: O(n)

---

# Code
```python []
class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        # 1) Diagonal harvest for Child 1
        total = sum(fruits[i][i] for i in range(n))
        for i in range(n):
            fruits[i][i] = 0

        # 2) 1D DP helper for Child 2 & 3
        def collect_max() -> int:
            prev = [float('-inf')] * n
            prev[n-1] = fruits[0][n-1]
            for r in range(1, n):
                curr = [float('-inf')] * n
                lo = max(0, n-1-r)
                for c in range(lo, n):
                    m = prev[c]
                    if c > 0 and prev[c-1] > m:
                        m = prev[c-1]
                    if c+1 < n and prev[c+1] > m:
                        m = prev[c+1]
                    curr[c] = m + fruits[r][c]
                prev = curr
            return prev[n-1]

        # 3) Child 2 on original grid
        ans = total + collect_max()

        # 4) Transpose for Child 3
        for i in range(n):
            for j in range(i):
                fruits[i][j], fruits[j][i] = fruits[j][i], fruits[i][j]

        # 5) Child 3 on transposed grid
        ans += collect_max()
        return ans
```

