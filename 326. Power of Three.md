[LC.326](https://leetcode.com/problems/power-of-three/description/)

# Intuition
A number is a power of three if it can be expressed as $$ 3^x $$ for some integer $$ x \ge 0 $$.  
If we know the **largest** power of three that fits in a 32-bit signed integer range, any smaller power of three must be a divisor of it. This means we can check if our input `n` divides that largest power evenly â€” if it does, `n` must also be a power of three.

# Approach
1. Precompute the largest power of three within the problem constraints: $$ 3^{19} = 1162261467 $$.  
   - Why $$ 3^{19} $$? Because $$ 3^{20} $$ would exceed $$ 2^{31} - 1 $$, the max 32-bit signed integer.
2. For any positive integer `n`, check if `1162261467 % n == 0`.
   - If true, `n` is a divisor and hence a power of three.
   - If false, it cannot be a power of three.
3. This approach avoids loops and recursion entirely, relying only on a constant-time modulus check.

# Complexity
- Time complexity:  
  $$ O(1) $$ â€” Single modulus operation, no loops.
- Space complexity:  
  $$ O(1) $$ â€” Only a constant for the largest power of three is stored.


# Code
```python3 []
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and 1162261467 % n == 0
```
