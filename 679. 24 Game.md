[LC.679](https://leetcode.com/problems/24-game/description/)

# Intuition
We want to know if four numbers can be combined with `+ - * /` and parentheses to make `24`. This is a classic “try all combinations” search problem. The key insights:
- At any step, we can **pick two numbers**, replace them with the **result of an operation**, and **recurse** on the smaller set.
- We avoid floating-point errors by using `Fraction`, so exact arithmetic decides equality with `24`.
- We aggressively **prune duplicates** by sorting states and memoizing results.

# Approach
1. **State Representation**
   - Represent the multiset of current numbers as a **sorted tuple of `Fraction`s**. Sorting gives a **canonical form**, so `(2, 3, 5)` and `(3, 2, 5)` look the same to the cache.

2. **DFS + Memoization**
   - Base case: if the state has one number, return whether it equals `24` exactly.
   - Recursive step:
     - For every **pair** `(a, b)` in the state:
       - Build the **rest** of the state by removing `a` and `b`.
       - Generate all possible **results** from `{a+b, a*b, a-b, b-a, a/b (if b≠0), b/a (if a≠0)}`.
         - Note: we include both `a-b` and `b-a` (and both divisions) because subtraction and division are **non-commutative**.
       - For each result `v`, create a **new state** = `sorted(rest ∪ {v})` and recurse.
       - If any recursion returns `True`, we can stop early and bubble up `True`.
   - Use `@lru_cache(None)` on the DFS to memoize explored states and **cut repeated work**.

3. **Why a `set` of ops?**
   - Using a set for `ops` avoids trying the **same value** multiple times when operations coincide (e.g., `a*b` and `b*a`).

4. **Why exact arithmetic?**
   - Many solutions use floats with an epsilon, but that can be fragile. `Fraction` ensures **exact comparisons** like `state[0] == 24`.

# Complexity
- **Time Complexity:** Exponential in the number of cards.
  - Roughly, we choose pairs in `O(n^2)`, try up to **6 operations** (addition, multiplication, two subtractions, up to two divisions), and recurse on `n-1` numbers. With caching and canonicalization, many states collapse, but worst-case growth is still exponential (on four cards it’s fast in practice).
- **Space Complexity:** 
  - **O(S)** for the recursion stack and memo, where `S` is the number of distinct canonical states reachable (bounded and small for 4 numbers). Each state stores up to `n` `Fraction`s.


# Code
```python3 []
from fractions import Fraction

class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        state0 = tuple(sorted(Fraction(x) for x in cards))

        @lru_cache(None)
        def dfs(state: tuple[Fraction, ...]) -> bool:
            if len(state) == 1:
                return state[0] == 24
            n = len(state)
            for i in range(n):
                for j in range(i + 1, n):
                    a, b = state[i], state[j]
                    rest = state[:i] + state[i+1:j] + state[j+1:]

                    ops = {a + b, a * b, a - b, b - a}
                    if b != 0: ops.add(a / b)
                    if a != 0: ops.add(b / a)

                    for v in ops:
                        if dfs(tuple(sorted(rest + (v,)))):
                            return True
            return False

        return dfs(state0)
```
