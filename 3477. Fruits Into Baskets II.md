
[LC.3477](https://leetcode.com/problems/fruits-into-baskets-ii/description/)


## Intuition
We need to place each fruit, in order, into the earliest basket whose capacity can hold it. Once a basket is used, it canâ€™t be reused. We can scan the baskets list for the first fit and `pop` it out.

## Approach
1. **Iterate** over each `fruit` in `fruits`.  
2. For each fruit, **scan** the current `baskets` list from left to right:
   - As soon as you find a basket `cap` with `cap >= fruit`, **remove** that basket via `baskets.pop(i)` and **break** out of the scan.
3. If no basket is large enough, you simply move onâ€”the fruit remains unplaced.
4. At the end, the **remaining** length of `baskets` is exactly the number of fruits you failed to place (since each successful placement shrinks the list by one).

This is a straightforward **greedy** simulation that runs in $$\mathcal{O}(n^2)$$ worst-case time but is easy to read, maintain, and performs well for typical input sizes.

## Complexity
- **Time:**  
  - Outer loop over `fruits`: \(O(n)\)  
  - Inner scan over `baskets`: up to \(O(n)\) per fruit  
  - Overall: \(O(n^2)\)  
- **Space:**  
  - \(O(1)\) extra (in-place modification of `baskets`)

## Code
```python []
class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        for fruit in fruits:
            for i, cap in enumerate(baskets):
                if cap >= fruit:
                    baskets.pop(i)
                    break
        return len(baskets)
