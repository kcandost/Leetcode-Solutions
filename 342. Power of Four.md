[LC.342](https://leetcode.com/problems/power-of-four/description/)

# Intuition
A power of four means we can write the number as $$ 4^x $$ for some integer $$ x $$.  
Examples: $$ 1 = 4^0 $$, $$ 4 = 4^1 $$, $$ 16 = 4^2 $$, $$ 64 = 4^3 $$.

In binary:
- \( 1 = 1 \) → `1`
- \( 4 = `100` (bit 1 followed by two zeros)
- \( 16 = `10000` (bit 1 followed by four zeros)
- \( 64 = `1000000` (bit 1 followed by six zeros)

Notice two things:
1. They are **powers of two** — meaning only **one bit** is set to `1` in their binary form.
2. The `1` bit always appears at an **odd position** when counting bits from right to left starting at 1 (1st bit, 3rd bit, 5th bit, etc.).

This second property happens because powers of four skip every other power of two.  
Example: $$ 2^0, 2^2, 2^4, 2^6, ... $$

# Approach
We can check these properties without loops:
1. `n > 0` → Must be positive.
2. `(n & (n - 1)) == 0` → Checks that `n` has only one bit set (i.e., it’s a power of two).
   - Example: \( 10000_2 \) (16) & \( 01111_2 \) (15) = `00000`.
3. `(n & 0x55555555) != 0` → Checks that the `1` bit is in an odd position.  
   - `0x55555555` is `01010101010101010101010101010101` in binary, which has `1`s in all odd bit positions.  
   - This masks out any even bit positions so only valid powers of four pass.

This way, we avoid loops or recursion.

# Complexity
- Time complexity: $$O(1)$$ — constant-time bitwise checks.
- Space complexity: $$O(1)$$ — no extra space used.

# Code
```python3 []
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0
