[LC.808](https://leetcode.com/problems/soup-servings/description/?envType=daily-question&envId=2025-08-08)

# Intuition  
We need the probability that soup A runs out before soup B, plus half the probability they both run out on the same turn. Each turn removes one of four fixed amounts $$ (\Delta A, \Delta B) $$ chosen uniformly at random. If neither soup is empty, the problem “restarts” with reduced quantities. That suggests a **recursive** or **dynamic-programming** solution.

Because all pour sizes are multiples of 25 mL, we can **rescale** the problem by units of 25 mL. For example, if we have $$a$$ mL of A remaining, we work with  
$$
i = \lceil a/25 \rceil
$$  
units instead. The four pour options become $$ (4,0),\,(3,1),\,(2,2),\,(1,3) $$ in these units.

# Approach  
1. **Rescaling:**  
   $$
   N = \lceil n/25 \rceil,
   \quad
   \text{so we compute }P(N,N).
   $$  
2. **Define** $$P(i,j)$$ = “desired probability when A has $$i$$ units and B has $$j$$ units.”  
3. **Base cases:**  
   $$
   P(i,j) =
   \begin{cases}
     1, & i \le 0 < j,\\
     0, & j \le 0 < i,\\
     \tfrac12, & i \le 0,\; j \le 0.
   \end{cases}
   $$  
4. **Recurrence:** for $$i>0$$ and $$j>0$$,
   $$
   P(i,j) = \frac14 \sum_{(d_i,d_j)\in\{(4,0),(3,1),(2,2),(1,3)\}}
     P(i - d_i,\;j - d_j).
   $$  
   We memoize these values (or use a DP table).  
5. **Large-\(n\) optimization:** numerically, for $$N \gtrsim 200$$, $$P(N,N)$$ is effectively 1.0, so we can short-circuit and return 1.0.

# Complexity  
- **Time complexity:**  
  We compute $$P(i,j)$$ for $$i,j = 1\ldots N$$, each requiring four look-ups, so  
  $$
    O(N^2)
    \quad\text{where }N = \lceil n/25\rceil.
  $$  
- **Space complexity:**  
  We store a memo table of size $$(N+1)\times(N+1)$$, so  
  $$
    O(N^2).
  $$


# Code
```python3 []
class Solution:
    def soupServings(self, n: int) -> float:
        # Rescale into units of 25 mL
        N = math.ceil(n / 25)
        # For large N, probability → 1
        if N >= 200:
            return 1.0

        @lru_cache(None)
        def P(i: int, j: int) -> float:
            # If A empty and B still has >0
            if i <= 0 and j > 0:
                return 1.0
            # If B empty and A still has >0
            if i > 0 and j <= 0:
                return 0.0
            # Both empty simultaneously
            if i <= 0 and j <= 0:
                return 0.5

            # Otherwise, average over four pours
            total = 0.0
            for di, dj in [(4,0), (3,1), (2,2), (1,3)]:
                total += P(i - di, j - dj)
            return total * 0.25

        return P(N, N)
```
