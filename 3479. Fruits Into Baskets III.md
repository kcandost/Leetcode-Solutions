[LC.3479](https://leetcode.com/problems/fruits-into-baskets-iii/description/)

# Intuition  
We need to assign each fruit (in the given order) to the earliest basket whose remaining capacity can hold it. A simple loop over all baskets per fruit would take O(n) each time, leading to O(n²), which is too slow for n up to 10⁵. Instead, we want:

- **Fast “find first basket ≥ need”** → better than scanning O(n).  
- **Fast update when a basket is used** → mark its capacity as “gone” without re-scanning.

A **segment tree** lets us store the maximum capacity in every subrange of baskets. With it, we can in O(log n):

1. **Check** if any basket can hold the fruit (compare the root’s max).  
2. **Descend** the tree to find the leftmost position where capacity ≥ need.  
3. **Update** that position’s capacity to –1 (used) and refresh parent nodes.

Thus each fruit costs O(log n) instead of O(n).

# Approach  
1. **Build the tree**  
   - Pick `size` = next power of two ≥ n (for a complete binary tree).  
   - Create an array `tree` of length `2·size`.  
   - Store each basket’s capacity at leaf `tree[size + i]`.  
   - For each internal node `i` (from `size-1` down to `1`), set `tree[i] = max(tree[2·i], tree[2·i+1])`.  
2. **Query for a fruit `f`**  
   - If `tree[1] < f`, no basket can hold it → count unplaced.  
   - Otherwise start at node `i = 1`:  
     - While `i < size`:  
       - If left child `tree[2·i] ≥ f`, go left (`i = 2·i`); else go right (`i = 2·i+1`).  
     - When `i` reaches a leaf, compute `idx = i - size`. That is the basket index.  
3. **Update when used**  
   - To mark basket `idx` used, set `tree[size + idx] = -1`.  
   - Then walk `i //= 2` upward, resetting `tree[i] = max(tree[2·i], tree[2·i+1])` until reaching the root.  
4. **Loop** over all fruits, performing one query + one update per fruit.  

This gives **O(n log n)** overall.

# Complexity  
- Time complexity:  
  - **Build tree:** $$\mathcal{O}(n)$$
  - **Per fruit:** one query $$\mathcal{O}(log \ n)$$ + one update $$\mathcal{O}(log \ n)$$  
  - **Total:** $$\mathcal{O}(n \log n)$$  

- Space complexity:  
  - The segment tree array is size 2·(next power of two) → $$O(n)$$  

# Code
```python []
class SegmentTree:
    """Point-update + 'first ≥ x' query in O(log n)."""
    def __init__(self, arr: List[int]):
        self.n = len(arr)
        # next power of two ≥ n
        self.size = 1 << (self.n - 1).bit_length()
        self.tree = [0] * (2 * self.size)
        # initialize leaves with basket capacities
        self.tree[self.size:self.size + self.n] = arr
        # build internal max values
        for i in range(self.size - 1, 0, -1):
            self.tree[i] = max(self.tree[2*i], self.tree[2*i + 1])

    def find_first_ge(self, x: int) -> int:
        """Return smallest index i where capacity ≥ x, or -1."""
        if self.tree[1] < x:
            return -1
        i = 1
        # descend until leaf
        while i < self.size:
            # choose left child if it satisfies
            if self.tree[2*i] >= x:
                i = 2*i
            else:
                i = 2*i + 1
        idx = i - self.size
        return idx if idx < self.n else -1

    def update(self, pos: int, value: int):
        """Set basket 'pos' to 'value' and refresh parent nodes."""
        i = pos + self.size
        self.tree[i] = value
        i //= 2
        while i:
            self.tree[i] = max(self.tree[2*i], self.tree[2*i + 1])
            i //= 2

class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        st = SegmentTree(baskets)
        unplaced = 0

        for f in fruits:
            idx = st.find_first_ge(f)
            if idx == -1:
                unplaced += 1
            else:
                st.update(idx, -1)  # mark basket used
        return unplaced
