[LC.1198](https://leetcode.com/problems/find-smallest-common-element-in-all-rows/description/)

# Intuition
Rows are strictly increasing. If a target `t` is common to all rows, we can advance a pointer in each row until we reach `t` (or pass it). If any row *passes* `t`, then no smaller value can be common—so the next candidate must be the value we just overshot to. This is essentially a multi-way merge driven by a non-decreasing target.

# Approach
We keep one pointer per row and try to align all rows on the same value.

**1) Per-row pointers**
- `idx = [0]*m` tracks where we are in each row.
- Pointers only move forward thanks to sorted rows (no backtracking).

**2) Recursive matcher (`match(i, t)`)**
- Advance row `i` while `mat[i][idx[i]] < t`.
- If a row exhausts (`idx[i] == n`) → impossible → return a fail signal.
- Let `v = mat[i][idx[i]]`:
  - If `v > t`, row `i` overshot → escalate target to `v` (the smallest larger candidate seen so far).
  - If `v == t` and `i` is the last row → we aligned all rows → found the answer.
  - Else recurse to the next row.

**3) Driver loop**
- Initialize `t = max(row[0] for row in mat)` since no common element can be smaller than the largest first element.
- Call `match(0, t)`:
  - If any row fails → return `-1`.
  - If all match → return `t`.
  - If we must escalate → set `t` to the suggested larger value and repeat.
- Each pointer advances at most `n` times → total moves ≤ `m·n`.

# Complexity
- **Time:** O(m·n) — each of the `m` pointers advances at most `n` times.
- **Space:** O(m) — for the `idx` array and recursion depth (≤ m).

# Code
```python3 []
class Solution:
    def smallestCommonElement(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        idx = [0] * m

        def match(i: int, t: int):
            while idx[i] < n and mat[i][idx[i]] < t:
                idx[i] += 1
            if idx[i] == n:            # exhausted a row -> no common element
                return None, None
            v = mat[i][idx[i]]
            if v > t:                  # need to raise the target
                return False, v
            if i == m - 1:             # matched all rows
                return True, t
            return match(i + 1, t)

        t = max(row[0] for row in mat)
        while True:
            ok, val = match(0, t)
            if ok is None:  
                return -1
            elif ok:          
                return val
            t = val
