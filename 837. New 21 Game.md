[LC.837](https://leetcode.com/problems/new-21-game/description/)

# Intuition
Think of this game as building up probabilities step by step. Alice starts at 0 points, and every time she draws, she adds between `1` and `maxPts` points. She keeps drawing until her score is at least `k`. What we want to know is: when the game ends, how likely is it that her score is `n` or less?

The key idea is that the game behaves like a probability distribution. Each score you can reach has some chance of happening, and we can compute those chances one by one.

# Approach
We use dynamic programming to keep track of the probability of reaching each score.  
- Start with `dp[0] = 1.0` (since Alice always starts at 0).  
- For each possible score `i`, the probability of landing there is the average of the probabilities of the last `maxPts` scores before it (since from each of those you could jump forward to `i` with equal chance).  

The trick is efficiency: if we try to sum over all `maxPts` possibilities for every score, it’s too slow. Instead, we use a **sliding window sum** — a running total of the last `maxPts` probabilities — so each new state is computed in constant time.

At the end, Alice stops drawing once she has at least `k` points. So the answer is the total probability of ending up between `k` and `n` inclusive.

# Complexity
- Time complexity:  
  $$O(n)$$ — we process each score once, updating the sliding window in constant time.

- Space complexity:  
  $$O(n)$$ — we store the probability of reaching each score.


# Code
```python3 []
class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        # If Alice never draws (k == 0) or even the worst case (k-1 + maxPts)
        # can't exceed n, then the probability is 1.
        if k == 0 or n >= k - 1 + maxPts:
            return 1.0

        dp = [0.0] * (n + 1)
        dp[0] = 1.0

        window_sum = 1.0  # sum of last `maxPts` dp values that can transition to next
        for i in range(1, n + 1):
            dp[i] = window_sum / maxPts

            # Before reaching k, the state i can still draw again, so it contributes to the window.
            if i < k:
                window_sum += dp[i]

            # Slide the window: drop the dp[i - maxPts] term if it exits the window.
            if i - maxPts >= 0:
                window_sum -= dp[i - maxPts]

        # Valid terminal scores are k..n (inclusive). Built-in sum over the slice is fast in C.
        return sum(dp[k: n + 1])
```
