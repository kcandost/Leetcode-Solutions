[LC.869](https://leetcode.com/problems/reordered-power-of-2/description/?envType=daily-question&envId=2025-08-10)


# Intuition
If two numbers have the same multiset of digits, one can be permuted to the other. So `n` can be reordered to a power of two iff its **digit counts** match the digit counts of some `2^k` within range.

# Approach
Instead of sorting strings or using a `Counter`, we encode digit counts into a compact integer “signature”:

- Allocate **4 bits per digit** (a nibble). Digit `d` occupies bits `[4d .. 4d+3]`.
- Incrementing the count of digit `d` is `m += 1 << (4*d)`.  
  This works because the max count of any digit is ≤ 10, fitting in 4 bits.
- Precompute signatures for `2^0 … 2^29` (since `2^30 = 1,073,741,824 > 1e9`).
- Compute the signature of `n` and test if it’s in the set.

This avoids conversions to strings and sorting, giving small constant factors and O(1) performance for constraints.

# Complexity
- **Time complexity:** `O(D)` to build one signature (`D ≤ 10` digits). Precomputation is `O(30*D)` once.
- **Space complexity:** `O(1)` — storing ~30 signatures.

# Code
```python3 []
def _sig(x: int) -> int:
    m = 0
    while x:
        d = x % 10
        m += 1 << (d << 2)    # bump the nibble for digit d
        x //= 10
    return m

_POW2_SIGS = {_sig(1 << k) for k in range(30)}  # 2^0..2^29 (since 2^30 > 1e9)

class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        return _sig(n) in _POW2_SIGS
