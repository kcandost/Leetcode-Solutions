[LC.904](https://leetcode.com/problems/fruit-into-baskets/description/)

## Intuition

Given a list of integers representing fruit types on trees in a row, pick a contiguous sequence (starting anywhere, moving right) that contains at most two distinct fruit types. Return the maximum number of fruits you can collect.

This is equivalent to: find the longest subarray with at most two distinct values. As you scan from left to right, you want to keep track of a window that contains up to two fruit types and be able to quickly adjust when a third appears. The key observation: when a new third fruit comes, the best you can do is keep the tail of the current window consisting of the most recent contiguous run of one of the two types, and start a new window from there including the new fruit.

## Approach
Maintain four pieces of state while iterating:
- `last` and `second`: the two fruit types currently in the window, where `last` is the most recent fruit type seen.
- `last_count`: how many times `last` has appeared consecutively at the end of the current window.
- `curr`: size of the current valid window (containing at most two types).
- `res`: maximum seen window size.

For each fruit `f` in the array:
1. If `f` matches `last` or `second`, we can extend the existing window: increment `curr`.
2. If `f` is a new third type, we must drop the older of the two types except the trailing run of `last`. So reset `curr` to `last_count + 1` (keep the contiguous tail of `last` plus this new fruit).
3. Update `last_count`: if `f == last`, increment it; otherwise, shift `last` into `second`, set `last = f`, and reset `last_count = 1`.
4. Update `res` with the maximum of itself and `curr`.

This keeps the window valid with at most two types while being optimal in a single pass.

### Example walkthrough:  
Input: `[1,2,3,2,2]`  
- Traverse:
  - `1`: window=[1], curr=1, last=1, second=None, last_count=1 → res=1  
  - `2`: new type, window tail of last (1) + 2 → curr=2, last=2, second=1, last_count=1 → res=2  
  - `3`: third type appears, keep tail of last (2) which has length 1, plus 3 → curr=2, last=3, second=2, last_count=1  
  - `2`: matches `second` → curr=3, last shifts: since f != last, second=last(3), last=2, last_count=1  
  - Next `2`: matches `last` → curr=4, last_count=2 → res updates to 4  

Result is 4 for subarray `[3,2,2]` extended with previous `2`.

## Complexity
- Time: $$ \mathcal{O}(n) $$ — single pass over the input.  
- Space: $$ \mathcal{O}(1) $$ — constant extra variables.

## Code
```python []
class Solution:
    def totalFruit(self, fruits: list[int]) -> int:
        last = second = None
        last_count = curr = res = 0
        for f in fruits:
            if f == last or f == second:
                curr += 1
            else:
                curr = last_count + 1
            if f == last:
                last_count += 1
            else:
                last_count = 1
                second, last = last, f
            if curr > res:
                res = curr
        return res
