[LC.2787](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/description/)

# Intuition
We’re choosing a set of **distinct** integers whose x-th powers add up to `n`. That’s the classic **0/1 subset-sum counting** vibe: each available power can be either taken once or skipped. So we can count how many ways to reach every sum `0..n` using each power at most once.

# Approach
1. **Generate candidates:** Precompute all x-th powers `p = i**x` with `p ≤ n`. There are about `⌊n^(1/x)⌋` of them.
2. **DP over sums (0/1 style):** Let `dp[s]` be the number of ways to reach sum `s` using a prefix of the powers.
   - Initialize `dp[0] = 1` (one way to make zero: pick nothing).
   - For each power `p`, update `dp` **backwards** from `n` down to `p`:
     - `dp[s] += dp[s - p]` (add ways that end by taking `p` once).
   - Backward iteration ensures each power is used at most once (0/1 choice).
3. Answer is `dp[n]` modulo `1e9+7`.

This is compact, iterative, and avoids recursion/memoization overhead while exactly modeling “unique integers.”

# Complexity
- Time complexity:
  - Let `m = ⌊n^(1/x)⌋` be the number of powers. The DP does `m * n` updates:  
    $$O(n \cdot m) = O\!\big(n \cdot n^{1/x}\big).$$
- Space complexity:
  - One array of length `n + 1`: $$O(n).$$


# Code
```python3 []
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 1_000_000_007
        # Precompute all xth powers ≤ n
        powers, i = [], 1
        while (p := pow(i, x)) <= n:
            powers.append(p)
            i += 1

        # 0/1 subset-sum count: dp[s] = #ways to reach sum s using unique powers
        dp = [0] * (n + 1)
        dp[0] = 1
        for p in powers:
            for s in range(n, p - 1, -1):
                dp[s] = (dp[s] + dp[s - p]) % MOD
        return dp[n]

```
