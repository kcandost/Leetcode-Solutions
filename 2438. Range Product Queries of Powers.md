[LC.2438](https://leetcode.com/problems/range-product-queries-of-powers/description/)

# Intuition
We can write `n` as a sum of distinct powers of two:  
$$ n = \sum 2^{b_i} $$ where \(b_i\) are the bit indices with a `1`.  
The required `powers` array is exactly `[2^{b_0}, 2^{b_1}, …]` in ascending order.  
For any query `[L, R]`, the product is:
$$
\prod_{i=L}^{R} 2^{b_i} = 2^{\sum_{i=L}^{R} b_i}.
$$
So we only need fast range sums of the bit indices.

# Approach
1. Scan bits of `n` from LSB to MSB. Whenever bit `i` is set, append `i` to a running prefix sum `s`:  
   `s[k] = b_0 + b_1 + … + b_{k-1}` and `s[0] = 0`.  
2. For a query `[L, R]`, the exponent is `s[R+1] - s[L]`.  
3. Compute `pow(2, exponent, MOD)` for each query.

# Complexity
- Time complexity:  
  Building prefix once in `O(#bits in n)`; each query answered in `O(1)`.  
  Overall `O(#bits + #queries)`.
- Space complexity:  
  `O(#set_bits)` for the prefix array.

# Code
```python3 []
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        MOD = 1000000007
        s, acc = [0], 0                     # prefix sums of set-bit indices
        for i in range(n.bit_length()):
            if (n >> i) & 1:
                acc += i
                s.append(acc)
        return [pow(2, s[r + 1] - s[l], MOD) for l, r in queries]
```
